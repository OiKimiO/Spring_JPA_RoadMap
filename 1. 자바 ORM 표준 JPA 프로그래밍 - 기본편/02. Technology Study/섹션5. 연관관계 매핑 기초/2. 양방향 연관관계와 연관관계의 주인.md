### 날짜 : 2023-04-10 10:13
### 주제 : 양방향 연관관계와 연관관계의 주인
---
### 태그
* 

### 메모
* **양방향 매핑**
	* 테이블 연관관계
		* 외래키를 입력하면 따로 관계를 정의할 필요가 없다
	* 양방향 객체 연관관계
		* 각 객체의 연관관계가 있음을 표시해야한다

* **mappedBy**
	* 객체와 테이블간의 연관관계를 맺는 차이를 확인하는 참조형 속성
	* 객체 연관관계
		1. 회원 -> 팀 (단방향)
		2. 팀 -> 회원 (단방향)
	* 테이블 연관관계(따로 설정할게 없지만 표현을 양방향이라고 함)
		1. 회원 <->팀 (양방향)

* **객체의 양방향 관계**
	* 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 두 가지를 합쳐서 이야기한다.
	* 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리
		* A -> B (a.getB()) 
		* B -> A (b.getA())

* 두 객체 중 하나를 외래 키로 관리할 경우 ![[Pasted image 20230410102953.png]]
	* Member 객체와 Team 객체가 있고, 각 객체는 서로 연관관계를 가지고 있는 상태인데, 만약 Member의 Team_ID 값을 바꾼다고 가정했을 때 어떤 객체의 Team을 변경해야할까?
	* 객체를 변경하는 입장에서는 Member와 Team을 변경해야하지만 DB의 입장에서 보면 외래키인 Member의 Team_ID만 변경하면 됨
	* 결국 연관된 객체 하나에 외래키로 사용할 객체를 지정해야함
		* 객체의 외래키를 정하는 과정에서 나온 것이 **연관관계 주인**을 정하는 것

	* 연관관계 주인(Ownner)
		* 양방향 매핑 규칙
			* 객체의 두 관계 중 주인을 정해야함
			* **연관관계의 주인만이 외래 키를 관리 (등록, 수정)**
			* 주인이 아닌쪽은 읽기만 가능
			* 주인은 mappedBy 속성을 사용 X
				* 참조한다는 의미 (똑바로 찾아보자)
	
		* 누구를 주인으로 해야하나?
			* **외래 키가 있는 곳을 주인으로 정할 것**
			* 아래 예시에서는 Member객체가 연관관계의 주인![[Pasted image 20230410103945.png]]
				* 연관관계 주인은 단순히 외래키가 있는 쪽
					* Member 객체는 MEMBER 테이블과 매핑되어 있음
					* MEMBER 테이블과 매핑된 객체에서 외래키인 TEAM_ID를 관리하는 것이 더 명확하게 코딩할 수 있음
					* 만약 Team 객체가 MEMBER 테이블을 변경한다면 관계를 정의함에 있어 프로젝트가 확장 될 수록 복잡해질 우려가 있음 
					* 따라서 Member 객체를 통해 외래키를 관리하는 것이 맞음
					
	* 양방향 매핑시 가장 많이 하는 실수
		1. **연관관계 주인에 값을 입력하지 않았을 경우**
		2. **양방향 매핑시 연관관계 주인만 입력한 경우**
		3. **양방향 매핑시 무한 루프가 발생하는 경우**


	1. **연관관계 주인에 값을 입력하지 않았을 경우**
	* ![[Pasted image 20230410105902.png]]
		* member 변수를 저장하는 입장에서 연관관계의 주인은 Member, 참조하는 객체는 Team
		* 위의 코드는 참조하는 객체인 Team에 저장되지 않는다. 
		* MEMBER 테이블을 조회했을 경우 아래와 같이 Team_ID가 입력되지 않는다. 
		* ![[Pasted image 20230410110300.png]]
		* 그래서 연관관계의 주인인 Member 객체에 Team을 저장한다.
		* 
		* 코드 변경 
		* ![[Pasted image 20230410110510.png]]
		* 이후 정상적으로 데이터가 들어감
		
	* 양방향 매핑시 연관관계 주인만 입력한 경우![[Pasted image 20230410112427.png]]
		* 외래키가 있는 주인 객체(Member)에 team만 넣고 Team에서 멤버를 조회할 경우 
			* 데이터를 persist한 후 1차 캐시에 있는 내영을 DB에 적용하지 않음
			* 문제는 DB에 적용되지 않다 보니 Team 객체의 List member에는 값이 존재하지 않아 Team객체로 조회할 경우 조회가 되지 않음
			* 그래서 Member와 Team에 입력 값인 member를 추가해야함
			* 단, persist 이후 flush와 clear를 한다면 1차 캐시를 비우고 다시 DB를 조회하기에 주인 객체에만 넣어도 되지만 문제는 그렇게 flush와 clear를 하지않는다면 문제가 발생할 수 있음
			* 또한 양방향 객체에 member를 추가하는 것이 객체 지향에 더 맞음
				* 객체 지향적이라는 이유는 모르겠넹.. ^^
				
		* 연관관계 편의 메서드(영한 선생님 편의 명명)
			* 2가지 방법 중 한가지를 선택해서 처리하는 것이 옳음
			1. 주인 객체에 편의 메서드 추가 
				* ![[Pasted image 20230410130235.png]]
				* member.setTeam을 changeTeam으로 변경
				* 관례상 setTeam이라 하면 주인 객체에 대한 값만을 추가하는 것 같음
				* 그래서 changeTeam으로 메서드 명을 변경하고 각 Member class와 Team class에 데이터를 추가하도록 변경
				* ![[Pasted image 20230410130420.png]]
				* 기존의 Member객체에 team값을 추가
				* team의 Member List에 member를 추가시킴
				
			2. 참조 객체에 편의 메서드 추가
				* ![[Pasted image 20230410131402.png]]
				* team 객체에 서 Member와 Team 객체의 Member 값을 추가
				* ![[Pasted image 20230410131450.png]]
		
		  * 양방향 매핑시 무한 루프를 조심
			  1. toString()으로 인한 문제
				* Member 객체와 Team 객체 간의 각각 toString을 정의한 상태에서  조회한 데이터를 출력하면 아래와 같은 에러가 발생함
				* ![[Pasted image 20230410132706.png]]
				* Member
				* ![[Pasted image 20230410132440.png]]
				* Team
				* ![[Pasted image 20230410132504.png]]
				* 객체간 toString() 정의로 인한 오류 발생![[Pasted image 20230410132351.png]]
			2. JSON 생성 라이브러리 
				* 흠.. 이건 잘 모르겠네... ㅎ
			3. Controller에서 Entity를 반환
				* 무한루프 문제가 발생할 수 있음
				* API 스펙이 변경될 수 있는 문제가 있음
				* 결국 위와 같은 문제로 인해 DTO로 매핑하여 사용하는 것이 좋음
				
* JPA 설계시 단방향 매핑만으로 이미 연관관계 매핑은 완료
	* 처음에 양방향 매핑으로 설계를 하지말고 나름대로 설계를 마무리해야함
	* 양방향 설계를 하면 문제가 많이 발생할 수 있음 
* 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
* 실무에선 JPQL로 소스를 짜야할 경우가 많이 생김
* 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨
	* (테이블에 영향을 주진 않음)
	
### 출처(참고문헌)
-  

### 연결문서
- 